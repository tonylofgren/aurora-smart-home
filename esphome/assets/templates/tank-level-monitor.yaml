# Generated by esphome@aurora-smart-home v1.0.0
# https://github.com/tonylofgren/aurora-smart-home
#
# Tank Level Monitor
# ------------------
# Ultrasonic sensor for tank/container level monitoring:
# - Water tanks, cisterns, pools
# - Oil/fuel tanks
# - Grain silos, pellet storage
# - Rain barrels
#
# Hardware:
#   - ESP32 or ESP8266
#   - JSN-SR04T (waterproof ultrasonic)
#   - Or HC-SR04 (non-waterproof, cheaper)
#   - Optional: Temperature sensor for compensation
#
# How it works:
#   Measures distance from sensor to liquid surface,
#   calculates fill level based on tank dimensions.

substitutions:
  device_name: "tank-level"
  friendly_name: "Water Tank"

  # Ultrasonic sensor pins
  trigger_pin: "GPIO5"
  echo_pin: "GPIO4"

  # Tank dimensions (in cm)
  tank_height: "100"        # Total height
  sensor_offset: "5"        # Distance from sensor to max fill
  min_distance: "10"        # Minimum valid reading (cm)
  max_distance: "150"       # Maximum valid reading (cm)

  # Tank capacity (liters) - for volume calculation
  tank_capacity: "500"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "${device_name}-fallback"

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

logger:
  level: INFO

# =============================================================================
# Ultrasonic Sensor
# =============================================================================

sensor:
  # Raw distance measurement
  - platform: ultrasonic
    trigger_pin: ${trigger_pin}
    echo_pin: ${echo_pin}
    name: "${friendly_name} Distance"
    id: tank_distance
    update_interval: 30s
    pulse_time: 10us
    timeout: 3m
    unit_of_measurement: "cm"
    accuracy_decimals: 1
    filters:
      # Convert meters to cm
      - multiply: 100
      # Filter out invalid readings
      - filter_out: nan
      # Smooth out noise
      - median:
          window_size: 5
          send_every: 1
      # Clamp to valid range
      - clamp:
          min_value: ${min_distance}
          max_value: ${max_distance}

  # Fill level percentage
  - platform: template
    name: "${friendly_name} Level"
    id: tank_level
    unit_of_measurement: "%"
    icon: "mdi:water-percent"
    accuracy_decimals: 0
    lambda: |-
      float distance = id(tank_distance).state;
      if (isnan(distance)) return NAN;

      // Calculate fill level
      // distance = sensor_offset when full
      // distance = tank_height when empty
      float empty_distance = ${tank_height};
      float full_distance = ${sensor_offset};

      float level = (empty_distance - distance) / (empty_distance - full_distance) * 100;
      return clamp(level, 0.0f, 100.0f);
    update_interval: 30s

  # Volume in liters
  - platform: template
    name: "${friendly_name} Volume"
    id: tank_volume
    unit_of_measurement: "L"
    icon: "mdi:water"
    accuracy_decimals: 0
    lambda: |-
      float level = id(tank_level).state;
      if (isnan(level)) return NAN;
      return (level / 100.0) * ${tank_capacity};
    update_interval: 30s

  # Depth of liquid (cm)
  - platform: template
    name: "${friendly_name} Depth"
    unit_of_measurement: "cm"
    icon: "mdi:ruler"
    accuracy_decimals: 1
    lambda: |-
      float distance = id(tank_distance).state;
      if (isnan(distance)) return NAN;
      float depth = ${tank_height} - distance + ${sensor_offset};
      return max(0.0f, depth);
    update_interval: 30s

  # WiFi signal
  - platform: wifi_signal
    name: "${friendly_name} WiFi"
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "${friendly_name} Uptime"
    entity_category: diagnostic

# =============================================================================
# Binary Sensors (Alerts)
# =============================================================================

binary_sensor:
  # Low level warning (< 20%)
  - platform: template
    name: "${friendly_name} Low Level"
    device_class: problem
    lambda: return id(tank_level).state < 20;

  # Critical level (< 10%)
  - platform: template
    name: "${friendly_name} Critical Level"
    device_class: problem
    lambda: return id(tank_level).state < 10;

  # Tank full (> 95%)
  - platform: template
    name: "${friendly_name} Full"
    lambda: return id(tank_level).state > 95;

  - platform: status
    name: "${friendly_name} Status"

# =============================================================================
# Text Sensors
# =============================================================================

text_sensor:
  - platform: template
    name: "${friendly_name} State"
    lambda: |-
      float level = id(tank_level).state;
      if (level < 10) return {"Critical"};
      if (level < 20) return {"Low"};
      if (level < 50) return {"Medium"};
      if (level < 80) return {"Good"};
      if (level < 95) return {"High"};
      return {"Full"};
    update_interval: 60s

  - platform: version
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic

# =============================================================================
# Buttons
# =============================================================================

button:
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

  # Manual measurement trigger
  - platform: template
    name: "${friendly_name} Measure Now"
    icon: "mdi:radar"
    on_press:
      - component.update: tank_distance

# =============================================================================
# Calibration Numbers
# =============================================================================

number:
  # Adjustable tank height
  - platform: template
    name: "${friendly_name} Tank Height"
    id: tank_height_setting
    min_value: 50
    max_value: 300
    step: 1
    initial_value: ${tank_height}
    unit_of_measurement: "cm"
    optimistic: true
    restore_value: true
    entity_category: config

  # Adjustable sensor offset
  - platform: template
    name: "${friendly_name} Sensor Offset"
    id: sensor_offset_setting
    min_value: 0
    max_value: 50
    step: 1
    initial_value: ${sensor_offset}
    unit_of_measurement: "cm"
    optimistic: true
    restore_value: true
    entity_category: config

# =============================================================================
# Optional: Temperature Compensation
# =============================================================================

# Speed of sound varies with temperature
# Uncomment if you have a DS18B20 or similar

# one_wire:
#   - platform: gpio
#     pin: GPIO14

# sensor:
#   - platform: dallas_temp
#     address: 0x1234567890ABCDEF
#     name: "${friendly_name} Temperature"
#     id: ambient_temp
#     update_interval: 60s

# Then modify ultrasonic calculation to compensate:
# speed_of_sound (m/s) = 331.4 + 0.6 * temperature_celsius

# =============================================================================
# Alternative: Pressure-based Level Sensing
# =============================================================================

# For submerged sensor (more accurate):
# sensor:
#   - platform: adc
#     pin: GPIO34
#     name: "${friendly_name} Pressure"
#     id: pressure_raw
#     attenuation: 11db
#     filters:
#       - calibrate_linear:
#           - 0.5 -> 0      # 0 cm (4mA)
#           - 2.5 -> 100    # 100 cm (20mA)
