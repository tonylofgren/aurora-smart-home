# Generated by esphome@aurora-smart-home v1.0.0
# https://github.com/tonylofgren/aurora-smart-home
#
# Washing Machine Monitor
# -----------------------
# Smart vibration sensor to detect washing machine status:
# - Running/Stopped detection
# - Cycle completion notification
# - Power consumption (optional CT clamp)
# - Door open/closed (optional reed switch)
#
# Hardware:
#   - ESP32-C3 Mini or D1 Mini
#   - SW-420 vibration sensor or MPU6050
#   - SCT-013 CT clamp (optional for power)
#   - Reed switch (optional for door)

substitutions:
  device_name: "washing-machine"
  friendly_name: "Washing Machine"

  # Vibration sensor pin
  vibration_pin: "GPIO4"

  # CT clamp (optional)
  ct_pin: "GPIO0"

  # Door sensor (optional)
  door_pin: "GPIO5"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32-c3-devkitm-1
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "${device_name}-fallback"

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

logger:
  level: INFO

# =============================================================================
# Global Variables
# =============================================================================

globals:
  - id: vibration_count
    type: int
    restore_value: no
    initial_value: '0'

  - id: last_vibration
    type: unsigned long
    restore_value: no
    initial_value: '0'

  - id: cycle_start_time
    type: unsigned long
    restore_value: no
    initial_value: '0'

# =============================================================================
# Vibration Detection
# =============================================================================

binary_sensor:
  # Raw vibration sensor
  - platform: gpio
    pin:
      number: ${vibration_pin}
      mode: INPUT_PULLUP
    name: "${friendly_name} Vibration Raw"
    id: vibration_raw
    internal: true
    filters:
      - delayed_off: 500ms
    on_press:
      - lambda: |-
          id(vibration_count)++;
          id(last_vibration) = millis();

  # Running status (vibration in last 2 minutes)
  - platform: template
    name: "${friendly_name} Running"
    id: machine_running
    device_class: running
    lambda: |-
      unsigned long now = millis();
      unsigned long diff = now - id(last_vibration);
      // Running if vibration in last 2 minutes
      return diff < 120000 && id(vibration_count) > 10;
    on_press:
      - lambda: id(cycle_start_time) = millis();
      - logger.log: "Washing machine started!"
    on_release:
      - delay: 2min  # Debounce for pause between cycles
      - if:
          condition:
            binary_sensor.is_off: machine_running
          then:
            - logger.log: "Washing machine cycle complete!"
            - homeassistant.event:
                event: esphome.washing_complete
                data:
                  device: ${device_name}

  # Door sensor (optional)
  - platform: gpio
    pin:
      number: ${door_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Door"
    device_class: door
    filters:
      - delayed_on: 100ms
      - delayed_off: 100ms

  - platform: status
    name: "${friendly_name} Status"

# =============================================================================
# Sensors
# =============================================================================

sensor:
  # Vibration intensity (counts per minute)
  - platform: template
    name: "${friendly_name} Vibration Intensity"
    id: vibration_intensity
    unit_of_measurement: "vpm"
    icon: "mdi:vibrate"
    lambda: |-
      static unsigned long last_check = 0;
      static int last_count = 0;

      unsigned long now = millis();
      if (now - last_check >= 60000) {  // Every minute
        int diff = id(vibration_count) - last_count;
        last_count = id(vibration_count);
        last_check = now;
        return diff;
      }
      return {};
    update_interval: 10s

  # Cycle duration
  - platform: template
    name: "${friendly_name} Cycle Duration"
    id: cycle_duration
    unit_of_measurement: "min"
    icon: "mdi:timer"
    lambda: |-
      if (id(machine_running).state && id(cycle_start_time) > 0) {
        return (millis() - id(cycle_start_time)) / 60000.0;
      }
      return 0;
    update_interval: 30s

  # Power consumption (CT clamp - optional)
  - platform: ct_clamp
    sensor: ct_adc
    name: "${friendly_name} Power"
    id: power_consumption
    sample_duration: 200ms
    update_interval: 5s
    filters:
      - calibrate_linear:
          - 0.0 -> 0
          - 0.02 -> 100  # Calibrate with known load

  - platform: adc
    pin: ${ct_pin}
    id: ct_adc
    attenuation: 11db
    internal: true

  # Total energy (kWh)
  - platform: total_daily_energy
    name: "${friendly_name} Daily Energy"
    power_id: power_consumption
    unit_of_measurement: "kWh"
    filters:
      - multiply: 0.001

  # WiFi
  - platform: wifi_signal
    name: "${friendly_name} WiFi"
    update_interval: 60s
    entity_category: diagnostic

  - platform: uptime
    name: "${friendly_name} Uptime"
    entity_category: diagnostic

# =============================================================================
# Reset Counter
# =============================================================================

interval:
  - interval: 1h
    then:
      - lambda: |-
          // Reset vibration counter hourly to prevent overflow
          if (!id(machine_running).state) {
            id(vibration_count) = 0;
          }

# =============================================================================
# Text Sensors
# =============================================================================

text_sensor:
  - platform: template
    name: "${friendly_name} State"
    lambda: |-
      if (id(machine_running).state) {
        float mins = id(cycle_duration).state;
        if (mins < 10) return {"Starting"};
        if (mins < 30) return {"Washing"};
        if (mins < 50) return {"Rinsing"};
        return {"Spinning"};
      }
      return {"Idle"};
    update_interval: 30s

  - platform: version
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic

# =============================================================================
# Buttons
# =============================================================================

button:
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

  # Reset cycle
  - platform: template
    name: "${friendly_name} Reset Cycle"
    entity_category: config
    on_press:
      - lambda: |-
          id(vibration_count) = 0;
          id(cycle_start_time) = 0;
