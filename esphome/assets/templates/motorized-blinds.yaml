# Generated by esphome@aurora-smart-home v1.0.0
# https://github.com/tonylofgren/aurora-smart-home
#
# Motorized Blinds/Shades Controller
# -----------------------------------
# Control roller blinds, curtains, or venetian blinds:
# - Position control (0-100%)
# - Tilt control (venetian blinds)
# - Manual button override
# - Position memory
# - Obstacle detection
#
# Hardware:
#   - ESP32 or ESP8266
#   - Stepper motor (28BYJ-48 + ULN2003) or
#   - DC motor with encoder or
#   - Tubular motor (RF control)
#   - Limit switches (optional)
#   - Manual buttons (up/down/stop)
#
# Motor options:
#   1. Stepper (28BYJ-48) - Cheap, precise, slow
#   2. DC motor - Fast, needs encoder for position
#   3. Tubular motor - Professional, requires RF bridge

substitutions:
  device_name: "blinds-living-room"
  friendly_name: "Living Room Blinds"

  # Stepper motor pins (ULN2003 driver)
  stepper_pin_1: "GPIO5"
  stepper_pin_2: "GPIO18"
  stepper_pin_3: "GPIO19"
  stepper_pin_4: "GPIO21"

  # Manual buttons
  button_up_pin: "GPIO32"
  button_down_pin: "GPIO33"
  button_stop_pin: "GPIO25"

  # Limit switches (optional)
  limit_up_pin: "GPIO26"
  limit_down_pin: "GPIO27"

  # Stepper settings
  # Steps for full travel (calibrate for your blind length)
  max_steps: "10000"
  # Speed (steps per second)
  stepper_speed: "500"

esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32dev
  framework:
    type: arduino

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: "${device_name}-fallback"

api:
  encryption:
    key: !secret api_encryption_key

ota:
  - platform: esphome
    password: !secret ota_password

logger:
  level: INFO

# =============================================================================
# Globals for Position Tracking
# =============================================================================

globals:
  - id: current_position
    type: int
    restore_value: yes
    initial_value: '0'

  - id: target_position
    type: int
    restore_value: no
    initial_value: '0'

  - id: is_moving
    type: bool
    restore_value: no
    initial_value: 'false'

# =============================================================================
# Stepper Motor
# =============================================================================

stepper:
  - platform: uln2003
    id: blind_motor
    pin_a: ${stepper_pin_1}
    pin_b: ${stepper_pin_2}
    pin_c: ${stepper_pin_3}
    pin_d: ${stepper_pin_4}
    max_speed: ${stepper_speed} steps/s
    acceleration: inf
    deceleration: inf

# =============================================================================
# Cover Entity
# =============================================================================

cover:
  - platform: template
    name: "${friendly_name}"
    id: blind_cover
    device_class: blind
    has_position: true

    # Current position (0 = closed, 100 = open)
    lambda: |-
      return float(id(current_position)) / ${max_steps};

    # Open command
    open_action:
      - globals.set:
          id: target_position
          value: '${max_steps}'
      - globals.set:
          id: is_moving
          value: 'true'
      - stepper.set_target:
          id: blind_motor
          target: !lambda 'return ${max_steps};'

    # Close command
    close_action:
      - globals.set:
          id: target_position
          value: '0'
      - globals.set:
          id: is_moving
          value: 'true'
      - stepper.set_target:
          id: blind_motor
          target: 0

    # Stop command
    stop_action:
      - stepper.set_target:
          id: blind_motor
          target: !lambda 'return id(blind_motor).current_position;'
      - globals.set:
          id: is_moving
          value: 'false'
      - globals.set:
          id: current_position
          value: !lambda 'return id(blind_motor).current_position;'

    # Position command (0-100%)
    position_action:
      - globals.set:
          id: target_position
          value: !lambda 'return int(pos * ${max_steps});'
      - globals.set:
          id: is_moving
          value: 'true'
      - stepper.set_target:
          id: blind_motor
          target: !lambda 'return int(pos * ${max_steps});'

# =============================================================================
# Manual Buttons
# =============================================================================

binary_sensor:
  # Up button
  - platform: gpio
    pin:
      number: ${button_up_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Button Up"
    internal: true
    on_press:
      - cover.open: blind_cover
    on_release:
      - cover.stop: blind_cover

  # Down button
  - platform: gpio
    pin:
      number: ${button_down_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Button Down"
    internal: true
    on_press:
      - cover.close: blind_cover
    on_release:
      - cover.stop: blind_cover

  # Stop button
  - platform: gpio
    pin:
      number: ${button_stop_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Button Stop"
    internal: true
    on_press:
      - cover.stop: blind_cover

  # Upper limit switch
  - platform: gpio
    pin:
      number: ${limit_up_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Upper Limit"
    internal: true
    on_press:
      - cover.stop: blind_cover
      - globals.set:
          id: current_position
          value: '${max_steps}'
      - stepper.report_position:
          id: blind_motor
          position: ${max_steps}

  # Lower limit switch
  - platform: gpio
    pin:
      number: ${limit_down_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${friendly_name} Lower Limit"
    internal: true
    on_press:
      - cover.stop: blind_cover
      - globals.set:
          id: current_position
          value: '0'
      - stepper.report_position:
          id: blind_motor
          position: 0

  - platform: status
    name: "${friendly_name} Status"

# =============================================================================
# Position Update Loop
# =============================================================================

interval:
  - interval: 500ms
    then:
      - lambda: |-
          // Update current position from stepper
          id(current_position) = id(blind_motor).current_position;

          // Check if movement complete
          if (id(is_moving) && id(blind_motor).current_position == id(target_position)) {
            id(is_moving) = false;
          }

# =============================================================================
# Sensors
# =============================================================================

sensor:
  # Position as percentage
  - platform: template
    name: "${friendly_name} Position"
    unit_of_measurement: "%"
    icon: "mdi:blinds"
    lambda: |-
      return (float(id(current_position)) / ${max_steps}) * 100;
    update_interval: 1s

  - platform: wifi_signal
    name: "${friendly_name} WiFi"
    update_interval: 60s
    entity_category: diagnostic

# =============================================================================
# Calibration Buttons
# =============================================================================

button:
  - platform: restart
    name: "${friendly_name} Restart"
    entity_category: config

  # Set current as open position
  - platform: template
    name: "${friendly_name} Set Open Position"
    entity_category: config
    on_press:
      - stepper.report_position:
          id: blind_motor
          position: ${max_steps}
      - globals.set:
          id: current_position
          value: '${max_steps}'

  # Set current as closed position
  - platform: template
    name: "${friendly_name} Set Closed Position"
    entity_category: config
    on_press:
      - stepper.report_position:
          id: blind_motor
          position: 0
      - globals.set:
          id: current_position
          value: '0'

# =============================================================================
# Text Sensors
# =============================================================================

text_sensor:
  - platform: template
    name: "${friendly_name} State"
    lambda: |-
      if (id(is_moving)) {
        if (id(target_position) > id(current_position)) {
          return {"Opening"};
        } else {
          return {"Closing"};
        }
      }
      float pos = float(id(current_position)) / ${max_steps};
      if (pos < 0.05) return {"Closed"};
      if (pos > 0.95) return {"Open"};
      return {"Partially Open"};
    update_interval: 1s

  - platform: version
    name: "${friendly_name} ESPHome Version"
    entity_category: diagnostic

# =============================================================================
# Alternative: DC Motor with Time-Based Position
# =============================================================================

# For DC motors without encoder, use time-based positioning:
#
# substitutions:
#   open_duration: "30s"
#   close_duration: "30s"
#
# cover:
#   - platform: time_based
#     name: "${friendly_name}"
#     open_action:
#       - switch.turn_on: motor_up
#     open_duration: ${open_duration}
#     close_action:
#       - switch.turn_on: motor_down
#     close_duration: ${close_duration}
#     stop_action:
#       - switch.turn_off: motor_up
#       - switch.turn_off: motor_down

# =============================================================================
# Alternative: RF Tubular Motor Control
# =============================================================================

# For Tuya/Dooya RF motors, use remote_transmitter:
#
# remote_transmitter:
#   pin: GPIO14
#   carrier_duty_percent: 50%
#
# button:
#   - platform: template
#     name: "Blinds Up"
#     on_press:
#       - remote_transmitter.transmit_raw:
#           code: [300, -300, 300, -900, ...]  # RF code for up
